<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: parser.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: parser.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @file src/parser.js
 * @description Содержит в себе парсер исходного кода poonya, на выходе экспортируемых функций можно получить либо выражение, либо главную исполняемую последовательность
 * @author Astecom
 */

"use strict";

const { 
        PoonyaException
    ,   BadEmptyObjectException
    ,   ParserEmtyArgumentException
    ,   UnexpectedTokenException
    ,   BadArrowNotationJumpingToUpperLevel
    ,   BadArrowNotationJumpingTwoLevels
    ,   ParserLogicException
    ,   InvalidSequenceForLetiableAccessException
    ,   CriticalParserErrorUnexpectedEndOfInputException
    ,   SegmentationFaultEmptyArgumentException
    ,   SegmentationFaultMaximumSegmentsForBlockException
    ,   UnexpectedTokenStatement
    ,   UnexpectedWordTypeAndGetException
    ,   CriticalParserErrorException
    ,   CriticalParserErrorNoRawDataTransmittedException
    ,   CriticalParserErrorUnexpectedEndOfExpression
    ,   ParserUnfinishedNotationException
    } = require('./classes/exceptions'),
    { 
        maybeEquals
    ,   countKeys
    } = require('./utils'),
    {
        CHARTYPE
    ,   SERVICE
    } = require('./classes/static')
    ,   FunctionCall = require('./classes/excecution/expression/FunctionCall')
    ,   ObjectContructorCall = require('./classes/excecution/expression/ObjectContructorCall')
    ,   TernarOperator = require('./classes/excecution/expression/TernarOperator')
    ,   ExpressionGroup = require('./classes/excecution/expression/ExpressionGroup')
    ,   GetOperator = require('./classes/excecution/expression/GetOperator')
    ,   IfStatement = require('./classes/excecution/statements/IfStatement')
    ,   SequenceGroup = require('./classes/excecution/statements/SequenceGroup')
    ,   OutStatement = require('./classes/excecution/statements/OutStatement')
    ,   WhileStatement = require('./classes/excecution/statements/WhileStatement')
    ,   RepeatStatement = require('./classes/excecution/statements/RepeatStatement')
    ,   SetStatement = require('./classes/excecution/statements/SetStatement')
    ,   ResetStatement = require('./classes/excecution/statements/ResetStatement')
    ,   PushStatement = require('./classes/excecution/statements/PushStatement')
    ,   SequenceMainGroup = require('./classes/excecution/statements/SequenceMainGroup')
    ,   linker = require('./linker');

/**
 * Парсит вызов функции, возвращает объект вызова функции, и позицию с которой можно продолжить прасинг
 *
 * @param {Array&lt;String|Number>} query_stack стек доступа к имени переменной
 * @param {Number} start Начальная позиция разбора, для выражения
 * @param {Array&lt;Token>} data Вхождения которые будут обработаны парсером
 * @param {Number} block_start Начальная позиция вызова
 * @param {Function} reject Вызываем при ошибке функция, котора первым аргументм принимает позицию вхождения на котором произошла ошибка
 *
 * @returns {{data: FunctionCall, jump: Number}} объект вызова функции, и позиция с которой можно продолжить прасинг
 *
 * @memberof Poonya.Parser
 * @protected
 */
function parseFunctionCall(query_stack, start, data, reject, block_start) {
    const args = segmentationParser(
        start,
        data,
        reject,
        ",",
        Infinity,
        `(${query_stack.map((e) => (typeof e === "number" ? `[${e}]` : e)).join(" => ")})()`
    );

    return {
        data: new FunctionCall(query_stack, args.data, block_start),
        jump: args.jump,
    };
}
/**
 * Парсит литеральное объявление объекта
 *
 * ->
 *  key1 -> value1,
 *  key2 -> value2,
 *  key1 --> value1...
 *
 * @param {Number[]|String[]|Operand[]} query_stack путь к конструктору объекта
 * @param {Number} start Начальная позиция разбора, для выражения
 * @param {Array&lt;Token>} data Вхождения которые будут обработаны парсером
 * @param {Function} reject Вызываем при ошибке функция, котора первым аргументм принимает позицию вхождения на котором произошла ошибка
 *
 * @returns {{data: ObjectContructorCall, jump: Number}} объект тернарного выражения, и позиция с которой можно продолжить прасинг
 *
 * @memberof Poonya.Parser
 * @protected
 */
function parseObject(query_stack, start, data, reject, level = 0) {
    let result = null,
        count = 0,
        entries = new Array([]),
        last_row = start,
        expected = 0; // Ожидаемое следующие значение

    for (let i = start;; i++) {
        switch (true) {
            case 
                data[i] === undefined || 
                expected === 3 &amp;&amp; !data[i].equals(CHARTYPE.OPERATOR, ',') ||
                data[i].equals(CHARTYPE.OPERATOR, [';', ')']):
                if (entries[entries.length - 1].length !== 2)
                    reject(data[i].position, new ParserUnfinishedNotationException());

                return {
                    data: new ObjectContructorCall(query_stack, new Map(entries), data[start].position),
                    jump: i - start
                };
            case data[i].equals(CHARTYPE.OPERATOR, '*') &amp;&amp; expected === 0:
                if (entries.length !== 1)
                    reject(data[i].position, new BadEmptyObjectException());

                return {
                    data: new ObjectContructorCall(query_stack, new Map(), data[start].position),
                    jump: i - start
                };
            case data[i].equals(CHARTYPE.NEWLINE):
                continue;
            default:
                switch (expected) {
                    case 0:
                        if (data[i].equals(CHARTYPE.WORD) || data[i].equals(CHARTYPE.STRING)) {
                            entries[entries.length - 1][0] = data[i].toRawString();
                        } else if (data[i].equals(CHARTYPE.NUMBER)) {
                            entries[entries.length - 1][0] = parseInt(data[i].toRawString());
                        } else {
                            reject(data[i].position, new UnexpectedTokenException(data[i], '[Word]'));
                        }

                        expected = 1;
                    continue;
                    case 1:
                        count = countKeys(data, i, CHARTYPE.OPERATOR, '-');

                        // - ('-' * level)
                        if (count === level + 1) {
                            i += count;

                            if (!data[i].equals(CHARTYPE.OPERATOR, '>')) {
                                reject(data[i].position, new UnexpectedTokenException(data[i], '>'));
                            }

                            expected = 2;
                        } else {
                            entries.pop();

                            if (count &lt; level + 1) {
                                return {
                                    data: new ObjectContructorCall(query_stack, new Map(entries), data[start].position),
                                    jump: last_row - start
                                };
                            } else {
                                reject(data[i].position, new BadArrowNotationJumpingToUpperLevel());
                            }
                        }
                    continue;
                    case 2:
                        count = countKeys(data, i + 1, CHARTYPE.OPERATOR, '-');

                        /// Если как значение передан инициализатор другого объекта
                        ///
                        /// some ->
                        ///     some1 --> 'some',
                        if (data[i + level + 3] != null &amp;&amp;
                            (
                                data[i].equals(CHARTYPE.WORD) ||
                                data[i].equals(CHARTYPE.NUMBER)
                            ) &amp;&amp;
                            count === level + 2 &amp;&amp;
                            data[i + level + 3].equals(CHARTYPE.OPERATOR, '>')) {
                            result = parseObject(SERVICE.CONSTRUCTORS.OBJECT, i, data, reject, level + 1);

                            i += result.jump - 1;

                            entries[entries.length - 1][1] = result.data;

                            expected = 3;

                            /// Неправильная нотация
                            /// Попытка произвести нотация на два уровня выше чем родительская
                            ///
                        } else if (count > level + 2) {
                            reject(data[i + 1].position, new BadArrowNotationJumpingTwoLevels());
                            /// Если как значение передано выражение
                            ///
                            /// some -> 'somesome...';
                        } else {
                            result = parseExpression(i, data, reject, [',', ';']);

                            // Текущие данные ставим как результат парсинга выражения
                            entries[entries.length - 1][1] = result.data;

                            // Ожидаем следующий маркер
                            expected = 3;

                            // Отматываем маркер пасинга назад
                            if(data[i].equals(CHARTYPE.OPERATOR, ';')) {
                                // Перемщаем картку за символ ;
                                i += result.jump - 2;
                            } else {
                                // Перемещаем картку после возвращенного маркера
                                i += result.jump - 1;
                            }
                        }
                    continue;
                    case 3:
                        entries.push([]);

                        last_row = i;

                        expected = 0;
                    continue;
                }
                break;
        }
    }
}
/**
 * Парсит тернарное выражение, возвращает объект тернарного выражения, и позицию с которой можно продолжить прасинг
 *
 * @param {ExpressionGroup} condition Условие, при котором тернарное выражение будет верным
 * @param {Number} start Начальная позиция разбора, для выражения
 * @param {Array&lt;Token>} data Вхождения которые будут обработаны парсером
 * @param {Function} reject Вызываем при ошибке функция, котора первым аргументм принимает позицию вхождения на котором произошла ошибка
 *
 * @returns {{data: TernarOperator, jump: Number}} объект тернарного выражения, и позиция с которой можно продолжить прасинг
 *
 * @memberof Poonya.Parser
 * @protected
 */
function parseTernar(condition, start, data, reject) {
    let hook_index = 0,
        buffer = new Array(),
        args = new Array();

    function push(token) {
        if (buffer.length !== 0) {
            args.push(parseExpression(0, buffer, reject).data);

            buffer.splice(0, buffer.length);
        }
        else
            reject(
                token != undefined ? token.position : data[start],
                new ParserEmtyArgumentException()
            );
    }

    for (let i = start;; i++) {
        switch (true) {
            case data[i] === undefined ||
                data[i].equals(CHARTYPE.OPERATOR, ";") ||
                data[i].equals(CHARTYPE.NEWLINE) ||
                (
                    data[i].equals(CHARTYPE.OPERATOR, ")") &amp;&amp;
                    hook_index &lt;= 0
                ):
                push(data[i]);

                if (args[0] === undefined || args[1] === undefined)
                    reject(
                        data[start].position,
                        new ParserEmtyArgumentException()
                    );

                return {
                    data: new TernarOperator(condition, args[0], args[1]),
                    jump: i -
                        start -
                        (data[i] &amp;&amp; data[i].equals(CHARTYPE.OPERATOR, ")")
                            ? 1
                            : 0),
                };
            case data[i].equals(CHARTYPE.OPERATOR, "("):
                buffer.push(data[i]);

                hook_index++;
                break;
            case data[i].equals(CHARTYPE.OPERATOR, ")"):
                buffer.push(data[i]);

                hook_index--;
                break;
            case data[i].equals(CHARTYPE.OPERATOR, ":") &amp;&amp;
                hook_index === 0 &amp;&amp;
                args.length === 0:
                push(data[i]);
                break;
            case data[i].equals(CHARTYPE.OPERATOR, ":") &amp;&amp;
                hook_index === 0 &amp;&amp;
                args.length !== 0:
                reject(
                    data[i].position,
                    new ParserLogicException()
                );
                break;
            default:
                buffer.push(data[i]);
                break;
        }
    }
}
/**
 * Парсит название, позвращает массив со стэком запроса, по которому можно получит доступ к переменной, и позицию с которой можно продолжить парсинг
 *
 * @param {Number} start Начальная позиция разбора, для выражения
 * @param {Array&lt;Token>} data Вхождения которые будут обработаны парсером
 * @param {Function} reject Вызываем при ошибке функция, котора первым аргументм принимает позицию вхождения на котором произошла ошибка
 *
 * @returns {{data: Array&lt;Number|String>, jump: Number}} массив со стэком запроса, по которому можно получит доступ к переменной, и позиция с которой можно продолжить парсинг
 *
 * @memberof Poonya.Parser
 * @protected
 */
function parseVarName(start, data, reject) {
    let buffer = new Array(),
        point_before = true,
        hook_index = 0,
        hook_start = 0;

    if (data.length === 0)
        return {
            data: [],
            jump: 0,
        };

    for (let i = start;; i++) {
        switch (true) {
            case data[i] == null ||
                (data[i].equals(CHARTYPE.OPERATOR) &amp;&amp;
                    !data[i].equals(CHARTYPE.OPERATOR, ["[", "]"])) ||
                data[i].equals(CHARTYPE.NEWLINE) ||
                data[i].equals(CHARTYPE.SPACE):
                return {
                    data: buffer,
                    jump: i - start,
                };
            case data[i].equals(CHARTYPE.WORD) &amp;&amp; point_before:
                buffer.push(data[i].toString());

                point_before = !point_before;
                continue;
            case data[i].equals(CHARTYPE.POINT) &amp;&amp; !point_before:
                point_before = !point_before;
                continue;
            case data[i].equals(CHARTYPE.OPERATOR, "[") &amp;&amp; !point_before:
                i++;
                // Индекс скобок
                hook_index = 0;
                // Позиция начала парсинга
                hook_start = i;

                // ...[3 + 4 + 5]...
                //    ^^^^^^^^^^
                while (data[i] != null &amp;&amp;
                    !(
                        data[i].equals(CHARTYPE.OPERATOR, "]") &amp;&amp;
                        hook_index === 0
                    )) {
                    if (data[i].equals(CHARTYPE.OPERATOR, "["))
                        hook_index++;
                    else if (data[i].equals(CHARTYPE.OPERATOR, "]"))
                        hook_index--;

                    i++;
                }

                if (hook_index != 0)
                    reject(
                        data[i].position,
                        new ParserLogicException()
                    );

                // Вставляем выражение как оператор доступа
                buffer.push(
                    parseExpression(0, data.slice(hook_start, i), reject)
                        .data
                );
                continue;
            default:
                reject(
                    data[i].position,
                    new InvalidSequenceForLetiableAccessException()
                );
                continue;
        }
    }
}
/**
 * Парсит выражение, позвращает выражение и позицию, с которой можно продолжить парсинг
 *
 * @param {Number} start Начальная позиция разбора, для выражения
 * @param {Array&lt;Token>} data Вхождения которые будут обработаны парсером
 * @param {Function} reject Вызываем при ошибке функция, котора первым аргументм принимает позицию вхождения на котором произошла ошибка
 * @param {String} end_marker Маркер конца выражения
 *
 * @returns {{data: ExpressionGroup, jump: Number}} выражение и позиция, с которой можно продолжить парсинг
 *
 * @memberof Poonya.Parser
 * @protected
 */
function parseExpression(start, data, reject, end_marker = ';') {
    if (data.length === 0)
        return {
            data: new ExpressionGroup(0),
            jump: 0,
        };

    const buffer = new ExpressionGroup(data[0].position)
        , result = new Array();

    for (let i = start;; i++) {
        if (
            data[i] == undefined ||
            data[i].equals(CHARTYPE.OPERATOR, ")") ||
            data[i].contentEquals(end_marker)
        ) {
            if (buffer.isNotDone())
                reject(data[i - 1].position, data[i] == undefined ? new CriticalParserErrorUnexpectedEndOfInputException() : new CriticalParserErrorUnexpectedEndOfExpression());

            buffer.complete(reject);

            return {
                data: buffer,
                jump: i - start,
            };
        }

        if(data[i].equals(CHARTYPE.NEWLINE))
            continue;

        switch (true) {
            // Какое-то слово
            case data[i].equals(CHARTYPE.WORD):
                // Ключевые слова
                switch (data[i].toString()) {
                    case "true": case "false": case "null":
                        buffer.append(data[i], reject);
                        continue;
                }

                result[0] = parseVarName(i, data, reject);

                if (data[i + result[0].jump] != null &amp;&amp; data[i + result[0].jump].equals(CHARTYPE.OPERATOR, "(")) {
                    // Функция
                    result[1] = parseFunctionCall(
                        result[0].data,
                        i + result[0].jump + 1,
                        data,
                        reject,
                        data[i].position
                    );

                    i += result[0].jump + result[1].jump + 1;

                    buffer.append(result[1].data, reject);
                } else if (
                    data[i + result[0].jump + 1] != null &amp;&amp;
                    data[i + result[0].jump].equals(CHARTYPE.OPERATOR, "-") &amp;&amp;
                    data[i + result[0].jump + 1].equals(CHARTYPE.OPERATOR, ">")
                ) {

                    // Конструктор объекта
                    result[1] = parseObject(
                        result[0].data,
                        i + result[0].jump + 2,
                        data,
                        reject,
                        0
                    );

                    i += result[0].jump + result[1].jump + 1;

                    if(data[i + 1].equals(CHARTYPE.OPERATOR, [ '*' ]))
                        i += 1;

                    buffer.append(result[1].data, reject);
                } else {
                    // Получение значения переменной
                    buffer.append(new GetOperator(data[i].position, result[0].data), reject);

                    i += result[0].jump - 1;
                }
            continue;
            // Конструктор объекта
            case data[i + 1] != null &amp;&amp;
                data[i].equals(CHARTYPE.OPERATOR, "-") &amp;&amp;
                data[i + 1].equals(CHARTYPE.OPERATOR, ">"):
                // Конструктор объекта
                result[0] = parseObject(
                    SERVICE.CONSTRUCTORS.OBJECT,
                    i + 2,
                    data,
                    reject,
                    0
                );

                i += result[0].jump + 2;

                buffer.append(result[0].data, reject);

            continue;
            // Другая группа выражений
            case data[i].equals(CHARTYPE.OPERATOR, "("):
                result[0] = parseExpression(i + 1, data, reject);

                i += result[0].jump + 1;

                buffer.append(result[0].data, reject);
            continue;
            // Тернарное выражение
            case data[i].equals(CHARTYPE.OPERATOR, "?"):
                buffer.complete(reject);

                result[0] = parseTernar(
                    new ExpressionGroup(data[i].position, buffer.data),
                    i + 1,
                    data,
                    reject
                );

                return {
                    data: result[0].data,
                    jump: i - start + result[0].jump + 2,
                };
            // Операторы строки числа и т.д
            case data[i].equals(CHARTYPE.STRING) ||
                data[i].equals(CHARTYPE.NUMBER) ||
                data[i].equals(CHARTYPE.OPERATOR, [
                    "/",
                    "*",
                    "+",
                    "-",
                    "!=",
                    ">",
                    "&lt;",
                    ">=",
                    "&lt;=",
                    "=",
                    "|",
                    "&amp;",
                ]):
                buffer.append(data[i], reject);
            continue;
            // Неизвестно что это, завершаем парсинг выражения на этом
            default:
                if (buffer.isNotDone())
                    reject(data[i - 1].position, new CriticalParserErrorUnexpectedEndOfExpression());

                buffer.complete(reject);

                return {
                    data: buffer
                };
        }
    }
}

/**
 * Парсит исполняемый сегмент, после чего возвращает величину прыжка и данные исполнения
 *
 * @param {Number} start Начальная позиция разбора, для выражения
 * @param {Array&lt;Token>} entries Вхождения которые будут обработаны парсером
 * @param {Function} reject {@link CodeEmitter.throwError} - Вызывается при ошибке функция, котора первым аргументом принимает позицию вхождения на котором произошла ошибка
 * @param {String} segment_separator Разделитель для сегментов
 * @param {Number} max_segments Максимальное число сегментов, если это число сегментов будет превышено, будет выбражено исключение
 * @param {String} blockname Название блока
 *
 * @returns {{data: Array&lt;ExpressionGroup>, jump: Number}} массив со стэком запроса, по которому можно получит доступ к переменной, и позиция с которой можно продолжить парсинг
 *
 * @memberof Poonya.Parser
 * @protected
 */
function segmentationParser(
    start,
    entries,
    reject,
    segment_separator = ",",
    max_segments = Infinity,
    blockname = "unknown"
) {
    let hook_index = 0,
        buffer = [new Array()];

    for (let i = start;; i++) {
        if(entries[i].equals(CHARTYPE.NEWLINE))
            continue;

        switch (true) {
            case entries[i] === undefined ||
                (entries[i].equals(CHARTYPE.OPERATOR, ")") &amp;&amp; hook_index &lt;= 0):
                if (buffer.length > 0 &amp;&amp; buffer[buffer.length - 1].length > 0) {
                    buffer[buffer.length - 1] = parseExpression(
                        0,
                        buffer[buffer.length - 1],
                        reject
                    ).data;
                } else if (buffer.length > 1) {
                    reject(
                        entries[i - 1].position,
                        new SegmentationFaultEmptyArgumentException(blockname)
                    );
                } else {
                    buffer.splice(buffer.length - 1, 1);
                }

                return {
                    // Сегменты
                    data: buffer,
                    // Прыжок парсера
                    jump: i - start,
                };
            case entries[i].equals(CHARTYPE.OPERATOR, "("):
                hook_index++;

                buffer[buffer.length - 1].push(entries[i]);
                continue;
            case entries[i].equals(CHARTYPE.OPERATOR, ")"):
                if (hook_index > 0) {
                    hook_index--;

                    buffer[buffer.length - 1].push(entries[i]);
                }
                else
                    reject(
                        entries[i].position,
                        new ParserLogicException()
                    );
                continue;
            case entries[i].contentEquals(segment_separator) &amp;&amp;
                hook_index === 0:
                    if (buffer[buffer.length - 1].length > 0) {
                        buffer[buffer.length - 1] = parseExpression(
                            0,
                            buffer[buffer.length - 1],
                            reject
                        ).data;

                        buffer.push(new Array());

                        if (buffer.length > max_segments)
                            reject(
                                entries[i].position,
                                new SegmentationFaultMaximumSegmentsForBlockException(blockname)
                            );
                    } else {
                        reject(
                            entries[i].position,
                            new SegmentationFaultEmptyArgumentException(blockname)
                        );
                    }
                break;
            default:
                buffer[buffer.length - 1].push(entries[i]);
                break;
        }
    }
}
/**
 * Используется для того, чтобы вырезать исполняемые сегменты из исполняемых блоков `{}`
 *
 * @param {Number} start Начальная позиция разбора, для выражения
 * @param {Array&lt;Token>} entries Вхождения которые будут обработаны парсером
 * @param {Function} reject Вызываем при ошибке функция, котора первым аргументм принимает позицию вхождения на котором произошла ошибка
 *
 * @returns {{data: Array&lt;SequenceGroup>, jump: Number}} массив с выражениями, и позиция с которой можно продолжить парсинг
 *
 * @memberof Poonya.Parser
 * @protected
 */
function segmentCutter(start, entries, reject) {
    let hook_index = 0,
        body = new Array();

    for (let i = start;; i++) {
        switch (true) {
            case entries[i] === undefined ||
                (entries[i].equals(CHARTYPE.OPERATOR, "}") &amp;&amp; hook_index &lt;= 0):
                return {
                    // Сегменты
                    data: codeBlockParser(0, body, reject).data,
                    // Прыжок парсера
                    jump: i - start,
                };
            case entries[i].equals(CHARTYPE.OPERATOR, "{"):
                hook_index++;

                body.push(entries[i]);
                continue;
            case entries[i].equals(CHARTYPE.OPERATOR, "}"):
                if (hook_index > 0) {
                    hook_index--;

                    body.push(entries[i]);
                }
                else
                    reject(
                        entries[i].position,
                        new ParserLogicException()
                    );
                continue;
            default:
                body.push(entries[i]);
                break;
        }
    }
}
/**
 * Парсит блок if, возвращзает серриализованый блок if.
 *
 * @param {Number} start Начальная позиция разбора, для выражения
 * @param {Array&lt;Token>} entries Вхождения которые будут обработаны парсером
 * @param {Function} reject Вызываем при ошибке функция, котора первым аргументм принимает позицию вхождения на котором произошла ошибка
 *
 * @returns {{data: IfStatement, jump: Number}} Объякт дескриптор блока if, и позиция с которой можно продолжить парсинг
 *
 * @memberof Poonya.Parser
 * @protected
 */
function ifStatementParser(start, entries, reject) {
    let index = start,
        result = new Array();

    if (maybeEquals(entries, index + 1, CHARTYPE.NEWLINE) &amp;&amp;
        entries[index + 1].equals(CHARTYPE.OPERATOR, "(")) {
        // statement ( ...parse... )
        result[0] = segmentationParser(
            index + 2,
            entries,
            reject,
            "",
            1,
            "if"
        );

        index += result[0].jump + 3;

        // { expression }
        if (maybeEquals(entries, index, CHARTYPE.NEWLINE) &amp;&amp;
            entries[index].equals(CHARTYPE.OPERATOR, "{")) {
            result[1] = segmentCutter(index + 1, entries, reject);

            index += result[1].jump + 1;

            // Else statement
            if (entries[index + 1] != null &amp;&amp;
                entries[index + 1].equals(CHARTYPE.WORD, "else")) {
                // { expression }
                if (maybeEquals(entries, index + 2, CHARTYPE.NEWLINE) &amp;&amp;
                    entries[index + 2].equals(CHARTYPE.OPERATOR, "{")) {
                    result[2] = segmentCutter(index + 3, entries, reject);

                    index += result[2].jump + 3;

                    return {
                        data: new IfStatement(
                            result[0].data[0],
                            result[1].data,
                            result[2].data
                        ),
                        jump: index - start,
                    };
                } else if (maybeEquals(entries, index + 2, CHARTYPE.NEWLINE) &amp;&amp;
                    entries[index + 2].equals(CHARTYPE.WORD, "if")) {
                    result[2] = ifStatementParser(
                        index + 2,
                        entries,
                        reject
                    );

                    index += result[2].jump + 2;

                    return {
                        data: new IfStatement(
                            result[0].data[0],
                            result[1].data,
                            result[2].data
                        ),
                        jump: index - start,
                    };
                } else {
                    reject(
                        entries[index + 2].position,
                        new UnexpectedTokenStatement(
                            "else",
                            entries[index + 2].toString(),
                            "{"
                        )
                    );
                }
            } else {
                return {
                    data: new IfStatement(result[0].data[0], result[1].data),
                    jump: index - start,
                };
            }
        } else {
            reject(
                entries[index].position,
                new UnexpectedTokenStatement(
                    "if",
                    entries[index].toString(),
                    "{"
                )
            );
        }
    } else {
        reject(
            entries[index + 1].position,
            new UnexpectedTokenStatement(
                "if",
                entries[index + 1].toString(),
                "("
            )
        );
    }
}
/**
 * Парсит тело (главное тело или секции исполняемых блоков) преобразуя вхождения в исполняемую последовательность.
 *
 * @param {Number} start Начальная позиция разбора, для выражения
 * @param {Array&lt;Token>} entries Вхождения которые будут обработаны парсером
 * @param {Function} reject Вызываем при ошибке функция, котора первым аргументм принимает позицию вхождения на котором произошла ошибка
 *
 * @returns {
 *      {
 *          data: SequenceGroup,
 *          jump: Number
 *      }
 * } Исполняемый стэк, и позиция с которой можно продолжить парсинг
 * @memberof Poonya.Parser
 * @protected
 */
function codeBlockParser(start, entries, reject) {
    const buffer = new SequenceGroup(),
        result = new Array();

    for (let i = start, leng = entries.length;; i++) {
        try {
            if (entries[i] == null) {
                return {
                    data: buffer,
                    jump: i - start,
                };
            }

            switch (true) {
                case entries[i].equals(CHARTYPE.NEWLINE):
                    continue;
                case entries[i].equals(CHARTYPE.OPERATOR, ">"):
                    result[0] = parseExpression(i + 1, entries, reject);

                    i += result[0].jump + 1;

                    buffer.push(new OutStatement(result[0].data));
                    continue;
                case entries[i].equals(CHARTYPE.WORD, "if"):
                    result[0] = ifStatementParser(i, entries, reject);

                    i += result[0].jump;

                    buffer.push(result[0].data);
                    continue;
                case entries[i].equals(CHARTYPE.WORD, "while"):
                    if (i + 1 &lt; leng &amp;&amp;
                        maybeEquals(entries, i + 1, CHARTYPE.NEWLINE) &amp;&amp;
                        entries[i + 1].equals(CHARTYPE.OPERATOR, "(")) {
                        // statement ( ...parse... )
                        result[0] = segmentationParser(
                            i + 2,
                            entries,
                            reject,
                            "",
                            1,
                            "while"
                        );

                        i += result[0].jump + 3;

                        // { expression }
                        if (maybeEquals(entries, i, CHARTYPE.NEWLINE) &amp;&amp;
                            entries[i].equals(CHARTYPE.OPERATOR, "{")) {
                            result[1] = segmentCutter(
                                i + 1,
                                entries,
                                reject
                            );

                            i += result[1].jump + 1;

                            buffer.push(
                                new WhileStatement(
                                    result[0].data[0],
                                    result[1].data
                                )
                            );
                        } else {
                            reject(
                                entries[i].position,
                                new UnexpectedTokenStatement(
                                    "while",
                                    entries[i].toString(),
                                    "{"
                                )
                            );
                        }
                    } else {
                        reject(
                            entries[i + 1].position,
                            new UnexpectedTokenStatement(
                                "while",
                                entries[i + 1].toString(),
                                "("
                            )
                        );
                    }
                    continue;
                case entries[i].equals(CHARTYPE.WORD, "repeat"):
                    if (i + 1 &lt; leng &amp;&amp;
                        maybeEquals(entries, i + 1, CHARTYPE.NEWLINE) &amp;&amp;
                        entries[i + 1].equals(CHARTYPE.OPERATOR, "(")) {
                        // statement ( ...parse... )
                        result[0] = segmentationParser(
                            i + 2,
                            entries,
                            reject,
                            ";",
                            2,
                            "repeat"
                        );

                        i += result[0].jump + 3;

                        // { expression }
                        if (maybeEquals(entries, i, CHARTYPE.NEWLINE) &amp;&amp;
                            entries[i].equals(CHARTYPE.OPERATOR, "{")) {
                            result[1] = segmentCutter(
                                i + 1,
                                entries,
                                reject
                            );

                            i += result[1].jump + 1;

                            buffer.push(
                                new RepeatStatement(
                                    result[0].data[0],
                                    result[0].data[1],
                                    result[1].data
                                )
                            );
                        } else {
                            reject(
                                entries[i].position,
                                new UnexpectedTokenStatement(
                                    "repeat",
                                    entries[i].toString(),
                                    "{"
                                )
                            );
                        }
                    } else {
                        reject(
                            entries[i + 1].position,
                            new UnexpectedTokenStatement(
                                "repeat",
                                entries[i + 1].toString(),
                                "("
                            )
                        );
                    }
                    continue;
                case entries[i].equals(CHARTYPE.WORD, "set"):
                    if (i + 1 &lt; leng &amp;&amp;
                        maybeEquals(entries, i + 1, CHARTYPE.NEWLINE) &amp;&amp;
                        entries[i + 1].equals(CHARTYPE.WORD)) {
                        if (i + 2 &lt; leng &amp;&amp;
                            maybeEquals(entries, i + 2, CHARTYPE.NEWLINE) &amp;&amp;
                            entries[i + 2].equals(CHARTYPE.OPERATOR, "=")) {
                            result[0] = parseExpression(
                                i + 3,
                                entries,
                                reject
                            );

                            buffer.push(
                                new SetStatement(entries[i + 1], result[0].data)
                            );

                            i += result[0].jump + 3;

                            continue;
                        } else {
                            reject(
                                entries[i + 3].position,
                                new UnexpectedWordTypeAndGetException(entries[i + 2].toString(), entries[i + 2].type)
                            );
                        }
                    } else {
                        reject(
                            entries[i + 2].position,
                            new UnexpectedWordTypeAndGetException(entries[i + 1].toString(), entries[i + 1].type)
                        );
                    }
                break;
                case entries[i].equals(CHARTYPE.WORD):
                    result[0] = parseVarName(i, entries, reject);

                    // Если следующий символ доступен
                    if (i + result[0].jump &lt; leng) {
                        // Переопределение
                        if (entries[i + result[0].jump].equals(
                            CHARTYPE.OPERATOR,
                            "="
                        )) {
                            result[1] = parseExpression(
                                result[0].jump + i + 1,
                                entries,
                                reject
                            );

                            buffer.push(
                                new ResetStatement(
                                    entries[i + result[0].jump].position,
                                    result[0].data,
                                    result[1].data
                                )
                            );

                            i += result[0].jump + result[1].jump + 1;

                            // Добавление
                        } else if (entries[i + result[0].jump].equals(
                            CHARTYPE.OPERATOR,
                            "&lt;"
                        )) {
                            if (entries[i + result[0].jump + 1].equals(
                                CHARTYPE.OPERATOR,
                                "-"
                            )) {
                                result[1] = parseExpression(
                                    result[0].jump + i + 2,
                                    entries,
                                    reject
                                );

                                buffer.push(
                                    new PushStatement(
                                        entries[i + result[0].jump].position,
                                        result[0].data,
                                        result[1].data
                                    )
                                );

                                i += result[0].jump + result[1].jump + 2;
                            } else {
                                reject(
                                    entries[i + result[0].jump + 1].position,
                                    new UnexpectedTokenException(
                                        entries[i + result[0].jump + 1].toString(),
                                        "-"
                                    )
                                );
                            }

                            // Вызов функции
                        } else if (entries[i + result[0].jump].equals(
                            CHARTYPE.OPERATOR,
                            "("
                        )) {
                            result[1] = parseExpression(
                                i,
                                entries,
                                reject
                            );

                            buffer.push(result[1].data);

                            i += result[1].jump;

                            // Ошибка
                        } else {
                            reject(
                                entries[i].position,
                                new InvalidSequenceForLetiableAccessException()
                            );
                        }
                    } else {
                        i += result[0].jump;
                    }
                    continue;
                case entries[i].equals(CHARTYPE.NUMBER) ||
                    entries[i].equals(CHARTYPE.STRING):
                    result[0] = parseExpression(i, entries, reject);

                    buffer.push(result[0].data);

                    i += result[0].jump;
                    continue;
                default:
                    reject(
                        entries[i].position,
                        new UnexpectedTokenException(
                            entries[i].toString(),
                            "*"
                        )
                    );
            }
        } catch (e) {
            if (e instanceof PoonyaException) {
                throw e;
            } else {
                if (entries.length != 0) {
                    if (entries[i] != null)
                        reject(entries[i].position, new CriticalParserErrorException());
                    else
                        reject(
                            entries[entries.length - 1].position,
                            new CriticalParserErrorUnexpectedEndOfInputException()
                        );
                } else {
                    reject(
                        0,
                        new CriticalParserErrorNoRawDataTransmittedException()
                    );
                }
            }
        }
    }
}
/**
 * Парсит вхождения, которые можно получить вызовом функции @see {@link lexer}
 *
 * @param {Array&lt;Token>} entries Вхождения которые будут обработаны парсером
 * @param {Function} reject {@link CodeEmitter.throwError} - Вызываем при ошибке функция, котора первым аргументм принимает позицию вхождения на котором произошла ошибка
 * @param {?String} parent_path Путь к шаблону
 *
 * @returns {SequenceMainGroup} Тело исполнителя
 *
 * @memberof Poonya.Parser
 * @protected
 * @async
 */
async function parser(entries, reject, parent_path) {
    return new SequenceMainGroup(codeBlockParser(
        0,
        await linker(
            entries,
            parent_path,
            reject
        ),
        reject
    ).data.Sequence);
}

/**
 * Парсит шаблон сообщения, которое помимо кода Poonya может содержать и любые другие символы вне префикса.
 * 
 * @param {Array&lt;Token>} entries Вхождения для парсинга
 * @param {String} block_prefix Префикс для обозначения начала блока кода poonya
 * @param {Function} reject {@link CodeEmitter.throwError} - Вызываем при ошибке функция, котора первым аргументм принимает позицию вхождени
 * @param {String} parent_path Путь к шаблону
 * 
 * @returns {SequenceMainGroup} Тело исполнителя
 *
 * @memberof Poonya.Parser
 * @protected
 * @async
 */
async function parserMP(entries, block_prefix, reject, parent_path) {
    let   hook_index = 0
        , buffer = new Array()
        , out = new SequenceMainGroup();

    for (let i = 0;; i++) {
        if(entries[i] == null)
            break;

        if (
            (
                block_prefix == null &amp;&amp;
                entries[i].equals(CHARTYPE.OPERATOR, "{") ||
                block_prefix != null &amp;&amp; 
                entries[i].contentEquals(block_prefix.toString()) &amp;&amp;
                (
                    entries[i + 1].equals(CHARTYPE.OPERATOR, "{") ||
                    entries[i + 1].equals(CHARTYPE.SPACE) &amp;&amp;
                    entries[i + 2].equals(CHARTYPE.OPERATOR, "{")
                )
            ) &amp;&amp;
            hook_index === 0
        ) {
            if(block_prefix != null)
                i += entries[i + 1].equals(CHARTYPE.SPACE) ? 2 : 1;

            if (buffer.length > 0) {
                out.push(new OutStatement(new ObjectContructorCall(SERVICE.CONSTRUCTORS.STRING, buffer.join(""), entries[i].position)));

                buffer.splice(0, buffer.length);
            }

            hook_index++;

            continue;
        } else if (
            entries[i].equals(CHARTYPE.OPERATOR, "}") &amp;&amp;
            hook_index === 1
        ) {
            out.push(
                codeBlockParser(
                    0,
                    await linker(
                        buffer.filter((e) => e.type !== CHARTYPE.SPACE),
                        parent_path,
                        reject
                    ),
                    reject
                ).data
            );

            buffer.splice(0, buffer.length);

            hook_index--;

            continue;
        } else {
            if(hook_index >= 1)
                switch (true) {
                    case entries[i].equals(CHARTYPE.OPERATOR, "{"):
                        hook_index++;
                        break;
                    case entries[i].equals(CHARTYPE.OPERATOR, "}"):
                        hook_index--;
                        break;
                }
        }

        if (!hook_index === 0) 
            buffer.push(entries[i].toString());
        else 
            buffer.push(entries[i]);
    }

    if (buffer.length !== 0)
        if (hook_index === 1) {
            out.push(
                codeBlockParser(
                    0,
                    await linker(
                        buffer.filter((e) => e.type !== CHARTYPE.SPACE),
                        parent_path,
                        reject
                    ),
                    reject
                ).data
            );

            buffer.splice(0, buffer.length);
        } else if (hook_index === 0) {
            if(buffer.length != 0) {
                out.push(
                    new OutStatement(new ObjectContructorCall(SERVICE.CONSTRUCTORS.STRING, buffer.join(""), entries[entries.length - 1].position))
                );

                buffer.splice(0, buffer.length);
            }
        } else {
            reject(
                entries[entries.length - 1].position,
                new UnexpectedTokenException(entries[entries.length - 1], "}"),
            );
        }

    return out;
}


module.exports.parser = parser;
module.exports.parserMP = parserMP;
module.exports.parseExpression = parseExpression;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="Poonya.html">Poonya</a></li><li><a href="Poonya.Data.html">Data</a></li><li><a href="Poonya.Exceptions.html">Exceptions</a></li><li><a href="Poonya.Expression.html">Expression</a></li><li><a href="Poonya.Lexer.html">Lexer</a></li><li><a href="Poonya.Linker.html">Linker</a></li><li><a href="Poonya.Parser.html">Parser</a></li><li><a href="Poonya.Statements.html">Statements</a></li><li><a href="Poonya.Static.html">Static</a></li><li><a href="Poonya.Storage.html">Storage</a></li><li><a href="Poonya.Utils.html">Utils</a></li></ul><h3>Classes</h3><ul><li><a href="CodeEmitter.html">CodeEmitter</a></li><li><a href="Context.html">Context</a></li><li><a href="ExecutionPattern.html">ExecutionPattern</a></li><li><a href="ExpressionPattern.html">ExpressionPattern</a></li><li><a href="FunctionCall.html">FunctionCall</a></li><li><a href="GetOperator.html">GetOperator</a></li><li><a href="Heap.html">Heap</a></li><li><a href="IfStatement.html">IfStatement</a></li><li><a href="iInputData.html">iInputData</a></li><li><a href="iPathData.html">iPathData</a></li><li><a href="iPoonyaConstructsData.html">iPoonyaConstructsData</a></li><li><a href="MessagePattern.html">MessagePattern</a></li><li><a href="NativeFunction.html">NativeFunction</a></li><li><a href="ObjectContructorCall.html">ObjectContructorCall</a></li><li><a href="Operand.html">Operand</a></li><li><a href="Operator.html">Operator</a></li><li><a href="OutStatement.html">OutStatement</a></li><li><a href="ParserData.html">ParserData</a></li><li><a href="Poonya.Exceptions.BadArrowNotationJTException.html">BadArrowNotationJTException</a></li><li><a href="Poonya.Exceptions.BadArrowNotationJTULException.html">BadArrowNotationJTULException</a></li><li><a href="Poonya.Exceptions.BadEmptyObjectException.html">BadEmptyObjectException</a></li><li><a href="Poonya.Exceptions.BadKeyInvalidTypeException.html">BadKeyInvalidTypeException</a></li><li><a href="Poonya.Exceptions.BadKeyProtectedFieldException.html">BadKeyProtectedFieldException</a></li><li><a href="Poonya.Exceptions.CriticalParserErrorException.html">CriticalParserErrorException</a></li><li><a href="Poonya.Exceptions.CriticalParserErrorNoRawDataTransmittedException.html">CriticalParserErrorNoRawDataTransmittedException</a></li><li><a href="Poonya.Exceptions.CriticalParserErrorUnexpectedEndOfExpression.html">CriticalParserErrorUnexpectedEndOfExpression</a></li><li><a href="Poonya.Exceptions.CriticalParserErrorUnexpectedEndOfInputException.html">CriticalParserErrorUnexpectedEndOfInputException</a></li><li><a href="Poonya.Exceptions.FieldNotAFunctionException.html">FieldNotAFunctionException</a></li><li><a href="Poonya.Exceptions.GetFieldOfNullException.html">GetFieldOfNullException</a></li><li><a href="Poonya.Exceptions.InvalidSequenceForLetiableAccessException.html">InvalidSequenceForLetiableAccessException</a></li><li><a href="Poonya.Exceptions.IsNotAConstructorException.html">IsNotAConstructorException</a></li><li><a href="Poonya.Exceptions.LinkerException.html">LinkerException</a></li><li><a href="Poonya.Exceptions.LinkerIOError.html">LinkerIOError</a></li><li><a href="Poonya.Exceptions.LinkerPathNotGiveExceptrion.html">LinkerPathNotGiveExceptrion</a></li><li><a href="Poonya.Exceptions.NativeFunctionExecutionError.html">NativeFunctionExecutionError</a></li><li><a href="Poonya.Exceptions.NativeFunctionReturnValueError.html">NativeFunctionReturnValueError</a></li><li><a href="Poonya.Exceptions.ParserEmtyArgumentException.html">ParserEmtyArgumentException</a></li><li><a href="Poonya.Exceptions.ParserException.html">ParserException</a></li><li><a href="Poonya.Exceptions.ParserLogicException.html">ParserLogicException</a></li><li><a href="Poonya.Exceptions.SegmentationFaultEmptyArgumentException.html">SegmentationFaultEmptyArgumentException</a></li><li><a href="Poonya.Exceptions.SegmentationFaultMaximumSegmentsForBlockException.html">SegmentationFaultMaximumSegmentsForBlockException</a></li><li><a href="Poonya.Exceptions.TheFieldAlreadyHasBeenDeclaredException.html">TheFieldAlreadyHasBeenDeclaredException</a></li><li><a href="Poonya.Exceptions.TheFieldMustBeAnArrayInstanceExceprion.html">TheFieldMustBeAnArrayInstanceExceprion</a></li><li><a href="Poonya.Exceptions.TheFieldMustBeNumberException.html">TheFieldMustBeNumberException</a></li><li><a href="Poonya.Exceptions.TheFieldNotHasDeclaredExceprion.html">TheFieldNotHasDeclaredExceprion</a></li><li><a href="Poonya.Exceptions.TheSequenceException.html">TheSequenceException</a></li><li><a href="Poonya.Exceptions.UnableToCreateAnObjectException.html">UnableToCreateAnObjectException</a></li><li><a href="Poonya.Exceptions.UnableToRecognizeTypeException.html">UnableToRecognizeTypeException</a></li><li><a href="Poonya.Exceptions.UnexpectedTokenException.html">UnexpectedTokenException</a></li><li><a href="Poonya.Exceptions.UnexpectedTokenStatement.html">UnexpectedTokenStatement</a></li><li><a href="Poonya.Exceptions.UnexpectedWordTypeAndGetException.html">UnexpectedWordTypeAndGetException</a></li><li><a href="PoonyaArray.html">PoonyaArray</a></li><li><a href="PoonyaBoolean.html">PoonyaBoolean</a></li><li><a href="PoonyaInteger.html">PoonyaInteger</a></li><li><a href="PoonyaNull.html">PoonyaNull</a></li><li><a href="PoonyaNumber.html">PoonyaNumber</a></li><li><a href="PoonyaObject.html">PoonyaObject</a></li><li><a href="PoonyaPattern.html">PoonyaPattern</a></li><li><a href="PoonyaPrototype.html">PoonyaPrototype</a></li><li><a href="PoonyaStaticLibrary.html">PoonyaStaticLibrary</a></li><li><a href="PoonyaString.html">PoonyaString</a></li><li><a href="PushStatement.html">PushStatement</a></li><li><a href="RepeatStatement.html">RepeatStatement</a></li><li><a href="SequenceGroup.html">SequenceGroup</a></li><li><a href="SequenceMainGroup.html">SequenceMainGroup</a></li><li><a href="SetStatement.html">SetStatement</a></li><li><a href="TernarOperator.html">TernarOperator</a></li><li><a href="Token.html">Token</a></li><li><a href="WhileStatement.html">WhileStatement</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Fri Jan 08 2021 14:54:38 GMT+0400 (Самарское стандартное время)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
